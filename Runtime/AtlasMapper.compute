#pragma kernel AtlasMapGeneratPadingEdgeBase
#pragma kernel AtlasMapGeneratPadingVartexBase

#include "./AtlasHelper.hlsl"
#include "./AtlasMapperHelper.hlsl"

uint Size;
RWStructuredBuffer<float2> Traiangles;
RWStructuredBuffer<float3> Result;

[numthreads(32, 32, 1)] void AtlasMapGeneratPadingEdgeBase(uint3 id: SV_DispatchThreadID)
{
  float3 TargetPos = float3(id.x + 0.25 , id.y + 0.25 , 0);//0.25で望ましい見た目になるが...なぜ0.25なのかは謎、0.5だとずれる
  float4 ClossT = ClossTraiangle(AsFloat3(Traiangles[SelectTraiangle(id.z,0)]),AsFloat3(Traiangles[SelectTraiangle(id.z,1)]),AsFloat3(Traiangles[SelectTraiangle(id.z,2)]),TargetPos);

  float3 Distans = DistansEdgeBase(Traiangles[SelectTraiangle(id.z,0)],Traiangles[SelectTraiangle(id.z,1)],Traiangles[SelectTraiangle(id.z,2)],(float2)TargetPos);
  float IsIn = IsInCal(ClossT.x,ClossT.y,ClossT.z);
  float IsDistans = isDistansCla(Distans, IsIn);

  float2 RevPos2 = FromBCS(Traiangles[SelectTraiangle(id.z,3)], Traiangles[SelectTraiangle(id.z,4)], Traiangles[SelectTraiangle(id.z,5)],ToBCS(ClossT));
  float3 RevPos3 = float3(saturate(RevPos2.x), saturate(RevPos2.y), IsDistans);

  uint resindex = TwoDToOneDIndex((uint2)id,Size);
  Result[resindex] = lerp(Result[resindex], RevPos3, step(Result[resindex].z, IsDistans));
}

[numthreads(32, 32, 1)] void AtlasMapGeneratPadingVartexBase(uint3 id: SV_DispatchThreadID)
{
  float3 TargetPos = float3(id.x + 0.25 , id.y + 0.25  , 0);
  float4 ClossT = ClossTraiangle(AsFloat3(Traiangles[SelectTraiangle(id.z,0)]),AsFloat3(Traiangles[SelectTraiangle(id.z,1)]),AsFloat3(Traiangles[SelectTraiangle(id.z,2)]),TargetPos);

  float3 Distans = DistansVartBase(Traiangles[SelectTraiangle(id.z,0)],Traiangles[SelectTraiangle(id.z,1)],Traiangles[SelectTraiangle(id.z,2)],(float2)TargetPos);
  float IsIn = IsInCal(ClossT.x,ClossT.y,ClossT.z);
  float IsDistans = isDistansCla(Distans, IsIn);

  float2 RevPos2 = FromBCS(Traiangles[SelectTraiangle(id.z,3)],Traiangles[SelectTraiangle(id.z,4)],Traiangles[SelectTraiangle(id.z,5)],ToBCS(ClossT));
  float3 RevPos3 = float3(saturate(RevPos2.x), saturate(RevPos2.y), IsDistans);

  uint resindex = TwoDToOneDIndex((uint2)id,Size);
  Result[resindex] = lerp(Result[resindex], RevPos3, step(Result[resindex].z, IsDistans));
}

/*
  // Result[resindex] = lerp(Result[resindex], RevPos3, IsIn);
  float Isinverted = cross(TraianglesPre[0] - TraianglesPre[1],
                           TraianglesPre[0] - float3(id.x + 0.5, id.y + 0.5,
  0)) .z; float Isinverted2 = cross(TraianglesPre[1] - TraianglesPre[2],
                            TraianglesPre[1] - float3(id.x + 0.5, id.y + 0.5,
  0)) .z; float Isinverted3 = cross(TraianglesPre[2] - TraianglesPre[0],
                            TraianglesPre[2] - float3(id.x + 0.5, id.y + 0.5,
  0)) .z;

  Isinverted = ceil(clamp(Isinverted, -1, 1));
  Isinverted2 = ceil(clamp(Isinverted2, -1, 1));
  Isinverted3 = ceil(clamp(Isinverted3, -1, 1));
  float IsIn = clamp(ceil(abs(Isinverted + Isinverted2 + Isinverted3) - 2.01),
  0, 1);

  float a = ((TraianglesPre[1].y - TraianglesPre[2].y) * (id.x -
  TraianglesPre[0].x) + (TraianglesPre[2].x - TraianglesPre[1].x) * (id.y -
  TraianglesPre[2].y)) /
            ((TraianglesPre[1].y - TraianglesPre[2].y) * (TraianglesPre[0].x -
  TraianglesPre[2].x) + (TraianglesPre[2].x - TraianglesPre[1].x) *
  (TraianglesPre[0].y - TraianglesPre[2].y)); float b = ((TraianglesPre[2].y -
  TraianglesPre[0].y) * (id.x - TraianglesPre[0].x) + (TraianglesPre[0].x -
  TraianglesPre[2].x) * (id.y - TraianglesPre[2].y)) /
            ((TraianglesPre[1].y - TraianglesPre[2].y) * (TraianglesPre[0].x -
  TraianglesPre[2].x) + (TraianglesPre[2].x - TraianglesPre[1].x) *
  (TraianglesPre[0].y - TraianglesPre[2].y)); float y = 1 - a - b;

  float3 BCS = float3(a, b, y);
*/
/*
lerp(Result[resindex],RevPos3,IsIn);
 float3(TraianglesPre[0],TraianglesPre[1],TraianglesPre[2]);
float3(Isinverted, Isinverted2, Isinverted3);
        lerp(Result[id.x + (id.y * Size)], RevPos3, IsIn);
float3(id.x,id.y,resindex );//
        */

/*

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
uint Size;
float3 TraianglesPre[3];
float2 TraianglesPost[3];
RWStructuredBuffer<float2> Traiangles;
RWStructuredBuffer<float3> Result;

{
  float3 TargetPos = float3(id.x + 0.5, id.y + 0.5, 0);
  float4 ClossT = ClossTraiangle(TraianglesPre[0],TraianglesPre[1],TraianglesPre[2],TargetPos);

  float3 Distans = DistansEdgeBase((float2)TraianglesPre[0],(float2)TraianglesPre[1],(float2)TraianglesPre[2],(float2)TargetPos);
  float IsIn = IsInCal(ClossT.x,ClossT.y,ClossT.z);
  float IsDistans = isDistansCla(Distans,Pading, IsIn);

  float2 RevPos2 = FromBCS(TraianglesPost[0],TraianglesPost[1],TraianglesPost[2],(ClossT.x/ClossT.w),(ClossT.y/ClossT.w),(ClossT.z/ClossT.w));
  float3 RevPos3 = float3(saturate(RevPos2.x), saturate(RevPos2.y), IsDistans);

  uint resindex = TwoDToOneDIndex((uint2)id,Size);
  Result[resindex] = lerp(Result[resindex], RevPos3, step(Result[resindex].z, IsDistans));
}

{
  float3 TargetPos = float3(id.x + 0.5, id.y + 0.5, 0);
  float4 ClossT = ClossTraiangle(TraianglesPre[0],TraianglesPre[1],TraianglesPre[2],TargetPos);

  float IsIn = IsInCal(ClossT.x,ClossT.y,ClossT.z);
  float3 Distans = DistansVartBase((float2)TraianglesPre[0],(float2)TraianglesPre[1],(float2)TraianglesPre[2],(float2)TargetPos);
  float IsDistans = isDistansCla(Distans,Pading, IsIn);

  float2 RevPos2 = FromBCS(TraianglesPost[0],TraianglesPost[1],TraianglesPost[2],(ClossT.x/ClossT.w),(ClossT.y/ClossT.w),(ClossT.z/ClossT.w));
  float3 RevPos3 = float3(saturate(RevPos2.x), saturate(RevPos2.y), IsDistans);

  uint resindex = TwoDToOneDIndex((uint2)id,Size);
  Result[resindex] = lerp(Result[resindex], RevPos3, step(Result[resindex].z, IsDistans));
}

*/